;GRUPO ALAMEDA 36 (al036)
;Nome: Joao Farinha Numero: 75667
;Nome: Joao Antunes Numero: 75993
;Nome: Diogo Rodrigues Numero: 77214

;;;;;;;;;;;;;;EXEMPLOS;;;;;;;;;;;;;;
(load "exemplos.fas")
;(load (compile-file "testes publicos/exemplos.lisp"))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;ESTRUTURAS;;;;;;;;;;;;;
(defstruct (restricao 
            (:constructor cria-restricao (variaveis funcao-validacao)))
  variaveis
  funcao-validacao
)

(defstruct (inferencia
            (:constructor cria-inefrencia (variavel dominio)))
  variavel
  dominio  
)

(defstruct (psr 
            (:constructor cria-psr (variaveis-todas dominio restricoes)))
  variaveis-todas
  dominio
  restricoes
  atribuicoes
)

;;;;;;;;;;;;AUX_FUNCS;;;;;;;;;;;;;;;
; devolve valor do par cuja variavel e = a variavel de input
(defun valor-lista-pares (variavel lista-pares)
  (cond ((null lista-pares) nil)
    ((equal variavel (car (first lista-pares))) (cdr (first lista-pares)))
    (t (valor-lista-pares variavel (rest lista-pares)))
  )
)

(defun not-lista-pares (variavel lista-pares)
  (cond ((null lista-pares) t)
    ((equal variavel (car (first lista-pares))) nil)
    (t (not-lista-pares variavel (rest lista-pares)))
  )
)

; verifica se a variavel pertence a lista
(defun pertence-lista (variavel lista)
  (cond ((null lista) nil)
    ((equal variavel (first lista)) t)
    (t (pertence-lista variavel (rest lista)))
  )
)

(defun pertence-restricao (restricao lista)
  (cond ((null lista) t)
    ((pertence-lista (first lista) (restricao-variaveis restricao)) (pertence-restricao restricao (rest lista)))
    (t nil)
  )
)

;compara 2 listas atraves de um predicado. A lista devolvida e o resultado da aplicacao do predicado aos elementos da lista1
;sobre a lista2. Sempre que este falhe os elementos nao sao incluidos na lista de resultado
(defun compara-listas (lista1 lista2 predicado)
  (cond ((null lista1) nil)
    ((funcall predicado (first lista1) lista2) (append (list (first lista1)) (compara-listas (rest lista1) lista2 predicado)))
    (t (compara-listas (rest lista1) lista2 predicado))
  )
)

;percorre duas listas em simultaneo devolvendo um valor da segunda sempre que encontrar a variavel na primeira
(defun mesmo-elemento (lista-teste lista-percorre variavel)
  (cond ((null lista-teste) nil)
    ((equal variavel (first lista-teste)) (first lista-percorre))
    (t (mesmo-elemento (rest lista-teste) (rest lista-percorre) variavel))
  )  
)

;igual a de cima, com substituicao caso encontre
(defun adiciona-mesmo-elemento (lista-teste lista-percorre variavel valor)
  (cond ((null lista-teste) nil)
    ((equal variavel (first lista-teste)) (append (list valor) (rest lista-percorre)))
    (t (append (list (first lista-percorre)) (adiciona-mesmo-elemento (rest lista-teste) (rest lista-percorre) variavel valor)))
  )  
)

(defun adiciona-elemento-lista (variavel valor lista)
  (cond ((null lista) (list valor))
    ((equal variavel (first lista)) (append (list valor) (rest lista)))
    (t (append (list (first lista)) (adiciona-elemento-lista variavel valor (rest lista))))
  )  
)

;adiciona o par variavel valor a lista de pares, ou susbtitui caso a variavel ja esteja atribuida
(defun adiciona-lista-pares (variavel valor lista-pares)
  (cond ((null lista-pares) (list (cons variavel valor)))
    ((equal variavel (car (first lista-pares))) (append (list (cons variavel valor)) (rest lista-pares)))
    (t (append (list (first lista-pares)) (adiciona-lista-pares variavel valor (rest lista-pares))))
  )
)

;remove o par cujo primeiro elemento e igual a variavel dada
(defun remove-lista-pares (variavel lista-pares)
  (cond ((null lista-pares) nil)
    ((equal variavel (car (first lista-pares))) (rest lista-pares))
    (t (append (list (first lista-pares)) (remove-lista-pares variavel (rest lista-pares))))
  )
)

(defun remove-lista (variavel lista)
  (cond ((null lista) nil)
    ((equal variavel (first lista)) (rest lista))
    (t (append (list (first lista)) (remove-lista variavel (rest lista))))
  )
)

(defun aplica-restricoes (p lista-restricoes count)
  (cond ((null lista-restricoes) (values t count))
    ((funcall (restricao-funcao-validacao (first lista-restricoes)) p) (aplica-restricoes p (rest lista-restricoes) (incf count)))
    (t (values nil (incf count)))
  )
)

(defun cria-variavel (linha coluna)
  (concatenate 'string "l" (write-to-string linha) "c" (write-to-string coluna))
)

(defun cria-predicado (valor-restricao variaveis)
  (let ((num0 0)
    (num1 0)
    (valor nil)
    (max-num0 (abs (- (list-length variaveis) valor-restricao)))
    (max-num1 valor-restricao)
    (variaveis variaveis))
  #'(lambda (psr)
      (setf num0 0)
      (setf num1 0)
      (dolist (variavel variaveis t)
        (setf valor (psr-variavel-valor psr variavel))
        (cond ((equal valor 0) (incf num0) (when (> num0 max-num0) (return nil)))
          ((equal valor 1) (incf num1) (when (> num1 max-num1) (return nil)))
        )
      )
    )
  )  
)


(defun nova-restricao (linha coluna valor limite-linha limite-coluna)
  (let ((lista-vars ()))
    (do ((x  (- linha 1) (incf x)))
      ((> x (+ linha 1)) nil)
      (cond ((or (> x  (- limite-linha 1)) (< x 0)) nil)
        (t (do ((y  (- coluna 1) (incf y)))
            ((> y (+ coluna 1)) nil)
            (cond ((or (> y  (- limite-coluna 1)) (< y 0)) nil)
              (t (setf lista-vars (append lista-vars (list (cria-variavel x y)))))
            )
          )
        )
      ) 
    )
    (cria-restricao lista-vars (cria-predicado valor lista-vars))  
  )  
)

;;;;;;;;;;;;;;;;;;;;;;;;REAL_DEAL;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun psr-variaveis-nao-atribuidas (p)
  (compara-listas (psr-variaveis-todas p) (psr-atribuicoes p) #'not-lista-pares)
)

(defun psr-variavel-valor (p variavel)
  (valor-lista-pares variavel (psr-atribuicoes p))  
)

(defun psr-variavel-dominio (p variavel)
  (mesmo-elemento (psr-variaveis-todas p) (psr-dominio p) variavel)
)

(defun psr-variavel-restricoes (p variavel)
  (compara-listas (psr-restricoes p) (list variavel) #'pertence-restricao)
)

(defun psr-adiciona-atribuicao! (p variavel valor)
  (setf (psr-atribuicoes p) (adiciona-lista-pares variavel valor (psr-atribuicoes p)))  
)

(defun psr-remove-atribuicao! (p variavel)
  (setf (psr-atribuicoes p) (remove-lista-pares variavel (psr-atribuicoes p)))  
)

(defun psr-altera-dominio! (p variavel dominio)
  (setf (psr-dominio p) (adiciona-mesmo-elemento (psr-variaveis-todas p) (psr-dominio p) variavel dominio))  
)

(defun psr-completo-p (p)
  (not (psr-variaveis-nao-atribuidas p))  
)

(defun psr-consistente-p (p)
  (aplica-restricoes p (psr-restricoes p) 0)
)

(defun psr-variavel-consistente-p (p variavel)
  (aplica-restricoes p (psr-variavel-restricoes p variavel) 0)
)

(defun psr-atribuicao-consistente-p (p variavel valor)
  (let ((valor-original (psr-variavel-valor p variavel)))
    (psr-adiciona-atribuicao! p variavel valor)
    (multiple-value-bind (result-p result-n) (psr-variavel-consistente-p p variavel)
      (cond ((null valor-original) (psr-remove-atribuicao! p variavel))
        ((not (equal valor  valor-original)) (psr-adiciona-atribuicao! p variavel valor-original)))
      (values result-p result-n)
    )
  )
)

(defun psr-atribuicoes-consistentes-arco-p (p variavel1 valor1 variavel2 valor2)
  (let ((restricoes (compara-listas (psr-restricoes p) (list variavel1 variavel2) #'pertence-restricao))
    (valor-original1 (psr-variavel-valor p variavel1))
    (valor-original2 (psr-variavel-valor p variavel2)))
    (psr-adiciona-atribuicao! p variavel1 valor1)
    (psr-adiciona-atribuicao! p variavel2 valor2)
    (multiple-value-bind (result-p result-n) (aplica-restricoes p restricoes 0)
      (cond ((null valor-original1) (psr-remove-atribuicao! p variavel1))
        ((not (equal valor1  valor-original1)) (psr-adiciona-atribuicao! p variavel1 valor-original1)))
      (cond ((null valor-original2) (psr-remove-atribuicao! p variavel2))
        ((not (equal valor2  valor-original2)) (psr-adiciona-atribuicao! p variavel2 valor-original2)))
      (values result-p result-n)
    )
  )
)

(defun fill-a-pix->psr (array)
  (let ((lista-vars ())
    (lista-restricoes ())
    (lista-dominios ()))
    (dotimes (x (array-dimension array 0) nil)
      (dotimes (y (array-dimension array 1) nil)
        (setf lista-vars (append lista-vars (list (cria-variavel x y))))
        (setf lista-dominios (append lista-dominios (list (list 0 1))))
        (when (aref array x y) (setf lista-restricoes (append lista-restricoes (list (nova-restricao x y (aref array x y) (array-dimension array 0) (array-dimension array 1))))))
      )
    )
    (cria-psr lista-vars lista-dominios lista-restricoes)
  )   
)

(defun psr->fill-a-pix (psr linhas colunas)
  (let ((array (make-array (list linhas colunas))))
    (dotimes (x linhas array)
      (dotimes (y colunas array)
        (setf (aref array x y) (psr-variavel-valor psr (cria-variavel x y)))
      )
    )
  )
)

(defun procura-retrocesso-simples (psr)
  (let ((result-num 0)
    (variavel nil))
    (cond ((psr-completo-p psr) (values psr result-num))
      (t (setf variavel (first (psr-variaveis-nao-atribuidas psr))) 
        (dolist (valor (psr-variavel-dominio psr variavel) (values nil result-num))
          (multiple-value-bind (result-p result-num-aux) (psr-atribuicao-consistente-p psr variavel valor)
            (incf result-num result-num-aux)
            (cond (result-p
                (psr-adiciona-atribuicao! psr variavel valor)
                (multiple-value-bind (result-p-aux result-num-aux) (procura-retrocesso-simples psr)
                  (incf result-num result-num-aux)
                  (cond (result-p-aux (return (values psr result-num)))
                    (t (psr-remove-atribuicao! psr variavel))
                  )
                )
              )
            )
          )
        )
      )
    )
  )  
)

(defun resolve-simples (array)
  (multiple-value-bind (psr unwanted) (procura-retrocesso-simples (fill-a-pix->psr array))
    (declare (ignore unwanted))
    (psr->fill-a-pix (procura-retrocesso-simples psr) (array-dimension array 0) (array-dimension array 1))
  )
)

(defun heuristica-grau (psr)
  (stable-sort (psr-variaveis-nao-atribuidas psr) #'> 
    :key #'(lambda (var) 
      (let ((restricoes (psr-variavel-restricoes psr var))
        (result 0))
        (dolist (restricao restricoes result)
          (when 
            (dolist (var-restricao (restricao-variaveis restricao))
              (when (and (null (psr-variavel-valor psr var-restricao)) (not (equal var-restricao var)))
                (return t)
              )
          ) (incf result))
        )
      )
    )
  ) 
)

(defun heuristica-mrv (psr)
  (stable-sort (psr-variaveis-nao-atribuidas psr) #'< 
    :key #'(lambda (var) 
      (list-length (psr-variavel-dominio psr var))
    )
  ) 
)

(defun envolvida-restricao (psr var1 var2)
  (dolist (restricao (psr-variavel-restricoes psr var1))
    (when (pertence-restricao restricao (list var2)) (return t))
  ) 
)

(defun arcos-vizinhos-nao-atribuidos (psr var)
  (let ((lista-arcos nil))
    (dolist (var-natribuida (psr-variaveis-nao-atribuidas psr) lista-arcos)
      (when (not (equal var var-natribuida))
        (when (envolvida-restricao psr var var-natribuida)
          (append lista-arcos (list (list var-natribuida var)))
        )
      )
    )
  )
)

(defun inferencia-variavel-dominio (inferencias var)
  (dolist (inferencia inferencias)
    (when (equal var (inferencia-variavel inferencia)) (return (inferencia-dominio inferencia)))
  )
)

(defun revise (psr v1 v2 inferencias)
  (let ((result-num 0)
    (dominio-v1 (inferencia-variavel-dominio inferencias v1))
    (novo-dominio-v1 nil)
    (dominio-v2 nil))
    (setf novo-dominio-v1 dominio-v1)
    (when (null dominio-v1) 
      (setf dominio-v1 (psr-variavel-dominio psr v1))
      (setf novo-dominio-v1 dominio-v1)
    )
    (setf dominio-v2 (psr-variavel-valor psr v2))
    (when (null dominio-v2)
      (setf dominio-v2 (inferencia-variavel-dominio inferencias v2))
      (when (null dominio-v2)
        (setf dominio-v2 (psr-variavel-dominio psr v2))
      )
    )
    (cond ((dolist (valor-dominio-v1 dominio-v1)
      (when (not (dolist (valor-dominio-v2 dominio-v2)
        (multiple-value-bind (result-p result-num-aux) (psr-atribuicoes-consistentes-arco-p psr v1 valor-dominio-v1 v2 valor-dominio-v2)
          (incf result-num result-num-aux)
          (when result-p
            (return t)
          )
        )))
        (remove-lista v1 novo-dominio-v1)
        (return t)
      ))
      (setf inferencias (adiciona-elemento-lista v1 novo-dominio-v1 inferencias))
      (values t result-num)
    )
    (t (values nil result-num)))
  )
)

(defun foward-checking (psr var)
  (let ((result-num 0)
    (inferencias nil)
    (lista-arcos (arcos-vizinhos-nao-atribuidos psr var)))
    (cond ((dolist (arco lista-arcos t)
      (multiple-value-bind (result-p result-num-aux) (revise psr (car arco) (cdr arco) inferencias)
        (incf result-num result-num-aux)
        (when result-p
          (when (= (list-length (inferencia-variavel-dominio inferencias (cdr arco))) 0)
            (return nil)
          )
        )
      )
    ) (values inferencias result-num))
    (t (values nil result-num)))
  )
)

;rever heuristica que e recalculada todas as chamadas
(defun procura-retrocesso-grau (psr)
  (let ((result-num 0)
    (variavel nil))
    (cond ((psr-completo-p psr) (values psr result-num))
      (t (setf variavel (first (heuristica-grau psr))) 
        (dolist (valor (psr-variavel-dominio psr variavel) (values nil result-num))
          (multiple-value-bind (result-p result-num-aux) (psr-atribuicao-consistente-p psr variavel valor)
            (incf result-num result-num-aux)
            (cond (result-p
                (psr-adiciona-atribuicao! psr variavel valor)
                (multiple-value-bind (result-p-aux result-num-aux) (procura-retrocesso-grau psr)
                  (incf result-num result-num-aux)
                  (cond (result-p-aux (return (values psr result-num)))
                    (t (psr-remove-atribuicao! psr variavel))
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)

;(defun procura-retrocesso-fc-mrv (psr)
;  (let ((result-num 0)
;    (variavel nil))
;    (cond ((psr-completo-p psr) (values psr result-num))
;      (t (setf variavel (first (heuristica-mrv psr))) 
;        (dolist (valor (psr-variavel-dominio psr variavel) (values nil result-num))
;          (multiple-value-bind (result-p result-num-aux) (psr-atribuicao-consistente-p psr variavel valor)
;            (incf result-num result-num-aux)
;            (cond (result-p
;                (psr-adiciona-atribuicao! psr variavel valor)
;                
;                (multiple-value-bind (result-p-aux result-num-aux) (foward-checking psr variavel valor)
;                  (incf result-num result-num-aux)
;                  (cond (result-p-aux
;                    )
;                  )
;                )
;                
;                (multiple-value-bind (result-p-aux result-num-aux) (procura-retrocesso-fc-mrv psr)
;                  (incf result-num result-num-aux)
;                  (cond (result-p-aux (return (values psr result-num)))
;                    (t (psr-remove-atribuicao! psr variavel))
;                  )
;                )
;              )
;            )
;          )
;        )
;      )
;    )
;  )
;)